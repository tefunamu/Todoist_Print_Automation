# Read configuration
$ConfigPath = "./config.json"
if (Test-Path $ConfigPath) {
    $Config = Get-Content $ConfigPath | ConvertFrom-Json
} else {
    Write-Host "Error: config.json not found"
    exit 1
}

# Read the text file generated by the Node.js script with proper encoding
Write-Host "Starting print script..."
$Text = Get-Content './tasks.txt' -Encoding UTF8 | Out-String
Write-Host "Text content loaded: $($Text.Length) characters"

# Determine printing mode
$PrintMode = $Config.printer.mode
Write-Host "Print mode: $PrintMode"

if ($PrintMode -eq "network") {
    # Network printing mode
    Write-Host "Using network printing mode"
    $PrinterIP = $Config.printer.network.ip
    $PrinterPort = $Config.printer.network.port
    $Timeout = $Config.printer.network.timeout
    
    # 疎通確認 - より堅牢な方法
    Write-Host "Testing printer reachability..."
    $PingSuccess = $false
    try {
        # 方法1: Test-Connection (PowerShell 4.0+)
        $PingResult = Test-Connection -ComputerName $PrinterIP -Count 1 -Quiet -ErrorAction SilentlyContinue
        if ($PingResult) {
            $PingSuccess = $true
            Write-Host "Ping test successful"
        }
    } catch {
        Write-Host "Test-Connection failed, trying alternative method..."
    }
    
    if (-not $PingSuccess) {
        try {
            # 方法2: pingコマンド (フォールバック)
            $PingOutput = ping $PrinterIP -n 1 -w 1000 2>$null
            if ($LASTEXITCODE -eq 0) {
                $PingSuccess = $true
                Write-Host "Ping test successful (alternative method)"
            }
        } catch {
            Write-Host "Alternative ping method also failed..."
        }
    }
    
    if (-not $PingSuccess) {
        Write-Host "Warning: Ping test failed, but continuing with connection attempt..."
        Write-Host "This might be due to firewall settings or printer configuration."
    }
    
    Write-Host "Connecting to printer at ${PrinterIP}:${PrinterPort} (timeout ${Timeout}ms)"
    
    # Create TCP client for network printing
    $TcpClient = New-Object System.Net.Sockets.TcpClient
    try {
        $iar = $TcpClient.BeginConnect($PrinterIP, $PrinterPort, $null, $null)
        if ($iar.AsyncWaitHandle.WaitOne($Timeout, $false)) {
            $TcpClient.EndConnect($iar)
            if ($TcpClient.Connected) {
                Write-Host "Connected to network printer successfully"
                
                # Get network stream
                $Stream = $TcpClient.GetStream()
                
                # 新：Shift_JIS（日本語プリンタ標準）
                try {
                    $encoding = [System.Text.Encoding]::GetEncoding("shift_jis")
                } catch {
                    # Fallback to UTF-8 if Shift_JIS is not available
                    $encoding = [System.Text.Encoding]::UTF8
                }
                $Bytes = $encoding.GetBytes($Text)
                
                # Send data to printer
                $Stream.Write($Bytes, 0, $Bytes.Length)
                $Stream.Flush()
                
                Write-Host "Data sent to network printer"
                
                # Close connection
                $Stream.Close()
                $TcpClient.Close()
                
                Write-Host "Network printing completed"
            } else {
                Write-Host "Connect succeeded but TcpClient.Connected is false"
                exit 1
            }
        } else {
            Write-Host "Connection attempt timed out"
            exit 1
        }
    } catch {
        Write-Host "Error during network connection: $($_.Exception.Message)"
        Write-Host "Falling back to USB printing mode..."
        $PrintMode = "usb"
    } finally {
        if ($TcpClient -and $TcpClient.Connected) {
            $TcpClient.Close()
        }
    }
}

if ($PrintMode -eq "usb") {
    # USB printing mode (original functionality)
    Write-Host "Using USB printing mode"
    
    Write-Host "Creating Word application..."
    $Word = New-Object -ComObject "Word.Application"

    # This keeps Microsoft Word invisible while it is open
    $Word.Visible = $False
    Write-Host "Word application created successfully"

    # Create a new Word document with specific template
    $Document = $Word.Documents.Add()
    Write-Host "Word document created"

    # Set document properties to avoid margin errors
    $Document.PageSetup.Orientation = 0  # Portrait orientation (0 = Portrait, 1 = Landscape)
    $Document.PageSetup.FirstPageTray = 0
    $Document.PageSetup.OtherPagesTray = 0

    # Create a range at the end of the Word document
    $Range = $Document.Content

    # Insert the text from the .txt file into the Word document with proper encoding
    $Range.Text = $Text
    Write-Host "Text inserted into document"

    # Set basic formatting for receipt printer (no custom font to avoid encoding issues)
    $Range.Font.Size = 8  # Smaller font size
    $Range.ParagraphFormat.LineSpacing = 10  # Tighter line spacing
    $Range.ParagraphFormat.SpaceAfter = 0    # No space after paragraphs
    $Range.ParagraphFormat.LeftIndent = 0    # No left indent
    $Range.ParagraphFormat.FirstLineIndent = 0  # No first line indent
    Write-Host "Basic formatting configured"

    # Access the PageSetup object to adjust margins (1 inch = 72 points)
    $PageSetup = $Document.PageSetup

    Write-Host "Page setup configured for receipt printer"

    # Save the document with proper encoding
    $Document.SaveAs('tasks.docx', 16)  # 16 = wdFormatDocumentDefault with encoding
    Write-Host "Document saved with encoding"

    # This will send the word document for printing to the default printer
    Write-Host "Attempting to print..."
    $Document.PrintOut()
    Write-Host "Print command sent"

    $printerName = (Get-WmiObject -Class Win32_Printer | Where-Object { $_.Default -eq $true }).Name
    Write-Host "Default printer: $printerName"

    do {
        Start-Sleep -Seconds 1
        $jobs = Get-PrintJob -PrinterName $printerName
        Write-Host "Print jobs in queue: $($jobs.Count)"
    } while ($jobs.Count -gt 0)

    Write-Host "Print jobs completed"

    # This command appears to be necessary in order to prevent some strange errors
    Start-Sleep -Seconds 20

    $Document.Close()
    $Word.Quit([ref]$false)
    Write-Host "Word application closed"

    # Release COM objects
    [System.Runtime.Interopservices.Marshal]::ReleaseComObject($Document) | Out-Null
    [System.Runtime.Interopservices.Marshal]::ReleaseComObject($Word) | Out-Null
    Write-Host "USB printing completed"
}

Write-Host "Print script completed"
